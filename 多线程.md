# 多线程

## 为什么需要多线程

- cpu 3Ghz 限制原因是发热量，想要发展出现了多核
- jvm 默认给你发一个线程，使得操作会更自然，但是会有性能问题

## 线程

- 主线程向下执行，达到new Thread start 时开启新线程，主线程继续向下执行
- start 开启新线程，主线程继续执行，run开启新线程，主线程等待线程执行完成后再继续进行
- 线程栈是私有的，局部变量是私有的， 类变量，静态变量都是公有的

- 多线程由于cpu切换速度快所以感觉是同时执行的，但是其实是线程之前疯狂切换，可能会导致同时操作中，共享变量的值在一个方法中改变了，但是当前进程被停止，然后其他进行进行操作又对这个进行了操作，然后又切换回了，但是你这个进程的变量已经不知道经过几次修改，导致你这个结果就会出现异常

## 多线程使用场景

- IO 密集型
  - stream
    1.  File 
    2.  网络（数据库）
- CPU 密集型，多线程提升有限
- 性能上线 
  1. 单核百分百
  2. 多核*n
- 本质上还是cpu速度太快了，为了让性能不浪费（不让cpu闲着）

## 多线程缺陷与解决

- 线程不安全所以加入 synchronized
- jps 查看java的进程
- jstack  查看java进程的栈信息

## 死锁

- 线程之间存在竞争资源，一个线程拿到另一个进程需求的锁，另一个进程同样需要这个线程的锁，使得两个线程进入死锁
- 锁，synchronized
  - 成员方法 锁 class  因为没有指定的对象
  - 实例方法 锁 this  有指定对象来调用

- java.until.concurrent java并发工具包
- 任何可能出现并发异常的情况，使用这个工具包的类
- AtomicInterger 原子的数字  线程安全的执行数字操作
- ReentrabtLock 可重入的锁  可以在一处加锁lock() 再另一处解锁unlock()

## Object

- wait()  让线程等待

  线程将当前锁释放

- notify()  唤醒线程

  任意唤醒一个在等待这个锁的线程

- notifyAll()  唤醒所有线程

  唤醒所有等待锁的线程

- 线程状态

  	1. 初始 New 未start之前
   	2. 运行 Ranable  start之后等待cpu是准备(ready)阶段，然后得到后进入运行阶段(runing)
   	3. 阻塞 Blocked线程阻塞于锁
   	4. 等待 Waiting 等待其他线程的通知或者中断 持续等待
   	5. 超时等待 Timed_Waiting 可以在指定时间自动返回 指定等待时长
   	6. 终止 Terminated 执行完毕 

## 生产者消费者模型

- synchronization

  代码块自动完成解锁操作，你需要判断等待与唤醒其他线程的情况

- ReentrantLock/Condition

  你需要完成锁的加锁与解锁，并且你还拥有额外的condition，所以可以在你进行等待时指定你的等待情况，可以针对特定等待线程进行唤醒。

- BlockingQueue

  拥有自动等待与执行的take和put，但是直接使用会导致执行过程稍有不同，添加额外的信号队列，可以使得执行过程得到控制

  

